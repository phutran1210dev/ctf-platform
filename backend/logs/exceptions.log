{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:00:04 GMT+0700 (Indochina Time)',
  process: {
    pid: 9222,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 87310336,
      heapTotal: 55803904,
      heapUsed: 22941008,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 10.6123046875, 12.4150390625, 12.1806640625 ],
    uptime: 703060
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:00:04'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:00:14 GMT+0700 (Indochina Time)',
  process: {
    pid: 9308,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86917120,
      heapTotal: 56066048,
      heapUsed: 22890176,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 10.07568359375, 12.23681640625, 12.11962890625 ],
    uptime: 703070
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:00:14'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:00:25 GMT+0700 (Indochina Time)',
  process: {
    pid: 9395,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86982656,
      heapTotal: 55541760,
      heapUsed: 23034400,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 9.28857421875, 11.99755859375, 12.03564453125 ],
    uptime: 703081
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:00:25'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:00:26 GMT+0700 (Indochina Time)',
  process: {
    pid: 9406,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 88096768,
      heapTotal: 55279616,
      heapUsed: 22788592,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 9.28857421875, 11.99755859375, 12.03564453125 ],
    uptime: 703082
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:00:26'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:00:31 GMT+0700 (Indochina Time)',
  process: {
    pid: 9455,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 87031808,
      heapTotal: 55803904,
      heapUsed: 22759960,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 9.74560546875, 12.04736328125, 12.052734375 ],
    uptime: 703087
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:00:31'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:00:50 GMT+0700 (Indochina Time)',
  process: {
    pid: 10239,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86573056,
      heapTotal: 56066048,
      heapUsed: 22808696,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 9.091796875, 11.76416015625, 11.951171875 ],
    uptime: 703106
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:00:50'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:01:24 GMT+0700 (Indochina Time)',
  process: {
    pid: 10620,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86147072,
      heapTotal: 55279616,
      heapUsed: 22760272,
      external: 2089705,
      arrayBuffers: 16879
    }
  },
  os: { loadavg: [ 8.09765625, 11.23291015625, 11.75 ], uptime: 703140 },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:01:24'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:01:30 GMT+0700 (Indochina Time)',
  process: {
    pid: 10736,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86376448,
      heapTotal: 55803904,
      heapUsed: 22629760,
      external: 2089705,
      arrayBuffers: 16879
    }
  },
  os: {
    loadavg: [ 7.84912109375, 11.12939453125, 11.71044921875 ],
    uptime: 703146
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:01:30'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:07:49 GMT+0700 (Indochina Time)',
  process: {
    pid: 15613,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86245376,
      heapTotal: 55541760,
      heapUsed: 22826560,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 9.73681640625, 10.18701171875, 10.9755859375 ],
    uptime: 703525
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:07:49'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:08:49 GMT+0700 (Indochina Time)',
  process: {
    pid: 16962,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86294528,
      heapTotal: 56066048,
      heapUsed: 22922928,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 9.4580078125, 10.052734375, 10.8720703125 ],
    uptime: 703585
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:08:49'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:09:10 GMT+0700 (Indochina Time)',
  process: {
    pid: 17251,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86327296,
      heapTotal: 55803904,
      heapUsed: 22825456,
      external: 2089705,
      arrayBuffers: 16879
    }
  },
  os: {
    loadavg: [ 8.9765625, 9.90283203125, 10.79833984375 ],
    uptime: 703606
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:09:10'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52
        logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\n\n      // Join user to their team room\n      if (user.teamId) {\n        socket.join(`team_${user.teamId}`);\n      }\n\n      // Join admin room if admin\n      if (user.role === 'admin') {\n        socket.join('admin');\n      }\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        message: 'Connected successfully',\n        user: {\n          id: user.id,\n          username: user.username,\n          role: user.role\n        }\n      });\n\n      // Handle disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n\n      // Handle joining challenge rooms\n      socket.on('join_challenge', (challengeId) => {\n        this.handleJoinChallenge(socket, challengeId);\n      });\n\n      // Handle leaving challenge rooms\n      socket.on('leave_challenge', (challengeId) => {\n        this.handleLeaveChallenge(socket, challengeId);\n      });\n\n      // Handle chat messages (if implementing chat)\n      socket.on('send_message', (data) => {\n        this.handleChatMessage(socket, data);\n      });\n\n    } catch (error) {\n      logger.error('Socket authentication error:', error);\n      socket.emit('error', { message: 'Authentication failed' });\n      socket.disconnect();\n    }\n  }\n\n  handleDisconnection(socket) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (userInfo) {\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\n      this.connectedUsers.delete(socket.id);\n    }\n  }\n\n  handleJoinChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.join(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\n  }\n\n  handleLeaveChallenge(socket, challengeId) {\n    if (!challengeId) return;\n    \n    socket.leave(`challenge_${challengeId}`);\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\n  }\n\n  handleChatMessage(socket, data) {\n    const userInfo = this.connectedUsers.get(socket.id);\n    if (!userInfo || !data.message) return;\n\n    const messageData = {\n      id: Date.now(),\n      username: userInfo.username,\n      message: data.message.substring(0, 500), // Limit message length\n      timestamp: new Date().toISOString(),\n      teamId: userInfo.teamId\n    };\n\n    // Emit to team room or global based on message type\n    if (data.type === 'team' && userInfo.teamId) {\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\n    } else if (data.type === 'global') {\n      this.io.emit('chat_message', messageData);\n    }\n\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\n  }\n\n  // Emit solve notifications\n  emitSolve(solveData) {\n    try {\n      const notification = {\n        type: 'solve',\n        challengeId: solveData.challengeId,\n        challengeTitle: solveData.challengeTitle,\n        username: solveData.username,\n        points: solveData.points,\n        isFirstBlood: solveData.isFirstBlood,\n        timestamp: new Date().toISOString()\n      };\n\n      // Emit to all connected users\n      this.io.emit('challenge_solved', notification);\n\n      // Emit to challenge room\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\n        type: 'solve_count_updated',\n        challengeId: solveData.challengeId\n      });\n\n      // Emit to team room\n      if (solveData.teamId) {\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\n      }\n\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\n    } catch (error) {\n      logger.error('Error emitting solve notification:', error);\n    }\n  }\n\n  // Emit leaderboard updates\n  emitLeaderboardUpdate(type = 'team') {\n    try {\n      this.io.emit('leaderboard_update', {\n        type,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.debug(`Leaderboard update emitted: ${type}`);\n    } catch (error) {\n      logger.error('Error emitting leaderboard update:', error);\n    }\n  }\n\n  // Emit admin notifications\n  emitAdminNotification(notification) {\n    try {\n      this.io.to('admin').emit('admin_notification', {\n        ...notification,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Admin notification emitted: ${notification.type}`);\n    } catch (error) {\n      logger.error('Error emitting admin notification:', error);\n    }\n  }\n\n  // Emit competition status updates\n  emitCompetitionUpdate(status) {\n    try {\n      this.io.emit('competition_update', {\n        status,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`Competition update emitted: ${status}`);\n    } catch (error) {\n      logger.error('Error emitting competition update:', error);\n    }\n  }\n\n  // Get connected users count\n  getConnectedUsersCount() {\n    return this.connectedUsers.size;\n  }\n\n  // Get users in specific room\n  getUsersInRoom(room) {\n    const roomUsers = [];\n    const sockets = this.io.sockets.adapter.rooms.get(room);\n    \n    if (sockets) {\n      sockets.forEach(socketId => {\n        const userInfo = this.connectedUsers.get(socketId);\n        if (userInfo) {\n          roomUsers.push(userInfo);\n        }\n      });\n    }\n    \n    return roomUsers;\n  }\n\n  // Broadcast system message\n  broadcastSystemMessage(message, type = 'info') {\n    try {\n      this.io.emit('system_message', {\n        type,\n        message,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info(`System message broadcasted: ${message}`);\n    } catch (error) {\n      logger.error('Error broadcasting system message:', error);\n    }\n  }\n}\n\nmodule.exports = SocketService;"}
                                                                                     ^
  
  SyntaxError: Invalid or unexpected token
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: 'uncaughtException: Invalid or unexpected token\n' +
    '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/services/socketService.js:52\n' +
    '      logger.info(`User connected via WebSocket: ${user.username} (${socket.id})`);\\n\\n      // Join user to their team room\\n      if (user.teamId) {\\n        socket.join(`team_${user.teamId}`);\\n      }\\n\\n      // Join admin room if admin\\n      if (user.role === \'admin\') {\\n        socket.join(\'admin\');\\n      }\\n\\n      // Send connection confirmation\\n      socket.emit(\'connected\', {\\n        message: \'Connected successfully\',\\n        user: {\\n          id: user.id,\\n          username: user.username,\\n          role: user.role\\n        }\\n      });\\n\\n      // Handle disconnection\\n      socket.on(\'disconnect\', () => {\\n        this.handleDisconnection(socket);\\n      });\\n\\n      // Handle joining challenge rooms\\n      socket.on(\'join_challenge\', (challengeId) => {\\n        this.handleJoinChallenge(socket, challengeId);\\n      });\\n\\n      // Handle leaving challenge rooms\\n      socket.on(\'leave_challenge\', (challengeId) => {\\n        this.handleLeaveChallenge(socket, challengeId);\\n      });\\n\\n      // Handle chat messages (if implementing chat)\\n      socket.on(\'send_message\', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error(\'Socket authentication error:\', error);\\n      socket.emit(\'error\', { message: \'Authentication failed\' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === \'team\' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit(\'chat_message\', messageData);\\n    } else if (data.type === \'global\') {\\n      this.io.emit(\'chat_message\', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: \'solve\',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit(\'challenge_solved\', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit(\'challenge_update\', {\\n        type: \'solve_count_updated\',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit(\'team_solve\', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting solve notification:\', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = \'team\') {\\n    try {\\n      this.io.emit(\'leaderboard_update\', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting leaderboard update:\', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to(\'admin\').emit(\'admin_notification\', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting admin notification:\', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit(\'competition_update\', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error(\'Error emitting competition update:\', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = \'info\') {\\n    try {\\n      this.io.emit(\'system_message\', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch (error) {\\n      logger.error(\'Error broadcasting system message:\', error);\\n    }\\n  }\\n}\\n\\nmodule.exports = SocketService;"}\n' +
    '                                                                                   ^\n' +
    '\n' +
    'SyntaxError: Invalid or unexpected token\n' +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js:7:23)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 18:09:13 GMT+0700 (Indochina Time)',
  process: {
    pid: 17340,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86556672,
      heapTotal: 55017472,
      heapUsed: 22607520,
      external: 2089705,
      arrayBuffers: 16879
    }
  },
  os: {
    loadavg: [ 8.73779296875, 9.837890625, 10.77001953125 ],
    uptime: 703609
  },
  trace: [
    {
      column: null,
      file: null,
      function: "messages (if implementing chat)\\n      socket.on('send_message', (data) => {\\n        this.handleChatMessage(socket, data);\\n      });\\n\\n    } catch (error) {\\n      logger.error('Socket authentication error:', error);\\n      socket.emit('error', { message: 'Authentication failed' });\\n      socket.disconnect();\\n    }\\n  }\\n\\n  handleDisconnection(socket) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (userInfo) {\\n      logger.info(`User disconnected: ${userInfo.username} (${socket.id})`);\\n      this.connectedUsers.delete(socket.id);\\n    }\\n  }\\n\\n  handleJoinChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.join(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} joined challenge room: ${challengeId}`);\\n  }\\n\\n  handleLeaveChallenge(socket, challengeId) {\\n    if (!challengeId) return;\\n    \\n    socket.leave(`challenge_${challengeId}`);\\n    logger.debug(`User ${socket.username} left challenge room: ${challengeId}`);\\n  }\\n\\n  handleChatMessage(socket, data) {\\n    const userInfo = this.connectedUsers.get(socket.id);\\n    if (!userInfo || !data.message) return;\\n\\n    const messageData = {\\n      id: Date.now(),\\n      username: userInfo.username,\\n      message: data.message.substring(0, 500), // Limit message length\\n      timestamp: new Date().toISOString(),\\n      teamId: userInfo.teamId\\n    };\\n\\n    // Emit to team room or global based on message type\\n    if (data.type === 'team' && userInfo.teamId) {\\n      this.io.to(`team_${userInfo.teamId}`).emit('chat_message', messageData);\\n    } else if (data.type === 'global') {\\n      this.io.emit('chat_message', messageData);\\n    }\\n\\n    logger.debug(`Chat message from ${userInfo.username}: ${data.message}`);\\n  }\\n\\n  // Emit solve notifications\\n  emitSolve(solveData) {\\n    try {\\n      const notification = {\\n        type: 'solve',\\n        challengeId: solveData.challengeId,\\n        challengeTitle: solveData.challengeTitle,\\n        username: solveData.username,\\n        points: solveData.points,\\n        isFirstBlood: solveData.isFirstBlood,\\n        timestamp: new Date().toISOString()\\n      };\\n\\n      // Emit to all connected users\\n      this.io.emit('challenge_solved', notification);\\n\\n      // Emit to challenge room\\n      this.io.to(`challenge_${solveData.challengeId}`).emit('challenge_update', {\\n        type: 'solve_count_updated',\\n        challengeId: solveData.challengeId\\n      });\\n\\n      // Emit to team room\\n      if (solveData.teamId) {\\n        this.io.to(`team_${solveData.teamId}`).emit('team_solve', notification);\\n      }\\n\\n      logger.info(`Solve notification emitted: ${solveData.challengeTitle} by ${solveData.username}`);\\n    } catch (error) {\\n      logger.error('Error emitting solve notification:', error);\\n    }\\n  }\\n\\n  // Emit leaderboard updates\\n  emitLeaderboardUpdate(type = 'team') {\\n    try {\\n      this.io.emit('leaderboard_update', {\\n        type,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.debug(`Leaderboard update emitted: ${type}`);\\n    } catch (error) {\\n      logger.error('Error emitting leaderboard update:', error);\\n    }\\n  }\\n\\n  // Emit admin notifications\\n  emitAdminNotification(notification) {\\n    try {\\n      this.io.to('admin').emit('admin_notification', {\\n        ...notification,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Admin notification emitted: ${notification.type}`);\\n    } catch (error) {\\n      logger.error('Error emitting admin notification:', error);\\n    }\\n  }\\n\\n  // Emit competition status updates\\n  emitCompetitionUpdate(status) {\\n    try {\\n      this.io.emit('competition_update', {\\n        status,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`Competition update emitted: ${status}`);\\n    } catch (error) {\\n      logger.error('Error emitting competition update:', error);\\n    }\\n  }\\n\\n  // Get connected users count\\n  getConnectedUsersCount() {\\n    return this.connectedUsers.size;\\n  }\\n\\n  // Get users in specific room\\n  getUsersInRoom(room) {\\n    const roomUsers = [];\\n    const sockets = this.io.sockets.adapter.rooms.get(room);\\n    \\n    if (sockets) {\\n      sockets.forEach(socketId => {\\n        const userInfo = this.connectedUsers.get(socketId);\\n        if (userInfo) {\\n          roomUsers.push(userInfo);\\n        }\\n      });\\n    }\\n    \\n    return roomUsers;\\n  }\\n\\n  // Broadcast system message\\n  broadcastSystemMessage(message, type = 'info') {\\n    try {\\n      this.io.emit('system_message', {\\n        type,\\n        message,\\n        timestamp: new Date().toISOString()\\n      });\\n\\n      logger.info(`System message broadcasted: ${message}`);\\n    } catch",
      line: null,
      method: 'info(`System message broadcasted: ${message}`);\\n    } catch',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/routes/challenges.js',
      function: null,
      line: 7,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:09:13'
}
{
  error: Error: write EPIPE
      at afterWriteDispatched (node:internal/stream_base_commons:161:15)
      at writeGeneric (node:internal/stream_base_commons:152:3)
      at Socket._writeGeneric (node:net:958:11)
      at Socket._write (node:net:970:8)
      at writeOrBuffer (node:internal/streams/writable:572:12)
      at _write (node:internal/streams/writable:501:10)
      at Writable.write (node:internal/streams/writable:510:10)
      at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)
      at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)
      at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139) {
    errno: -32,
    code: 'EPIPE',
    syscall: 'write'
  },
  level: 'error',
  message: 'uncaughtException: write EPIPE\n' +
    'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  stack: 'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  exception: true,
  date: 'Tue Nov 25 2025 18:22:01 GMT+0700 (Indochina Time)',
  process: {
    pid: 31263,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 88965120,
      heapTotal: 56541184,
      heapUsed: 27659736,
      external: 2238348,
      arrayBuffers: 18173
    }
  },
  os: {
    loadavg: [ 47.80322265625, 38.5107421875, 24.05029296875 ],
    uptime: 704377
  },
  trace: [
    {
      column: 15,
      file: 'node:internal/stream_base_commons',
      function: 'afterWriteDispatched',
      line: 161,
      method: null,
      native: false
    },
    {
      column: 3,
      file: 'node:internal/stream_base_commons',
      function: 'writeGeneric',
      line: 152,
      method: null,
      native: false
    },
    {
      column: 11,
      file: 'node:net',
      function: 'Socket._writeGeneric',
      line: 958,
      method: '_writeGeneric',
      native: false
    },
    {
      column: 8,
      file: 'node:net',
      function: 'Socket._write',
      line: 970,
      method: '_write',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/streams/writable',
      function: 'writeOrBuffer',
      line: 572,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: '_write',
      line: 501,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: 'Writable.write',
      line: 510,
      method: 'write',
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js',
      function: 'Console.log',
      line: 87,
      method: 'log',
      native: false
    },
    {
      column: 17,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js',
      function: 'Console._write',
      line: 103,
      method: '_write',
      native: false
    },
    {
      column: 139,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js',
      function: 'doWrite',
      line: 390,
      method: null,
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 18:22:01'
}
{
  error: Error: write EPIPE
      at afterWriteDispatched (node:internal/stream_base_commons:161:15)
      at writeGeneric (node:internal/stream_base_commons:152:3)
      at Socket._writeGeneric (node:net:958:11)
      at Socket._write (node:net:970:8)
      at writeOrBuffer (node:internal/streams/writable:572:12)
      at _write (node:internal/streams/writable:501:10)
      at Writable.write (node:internal/streams/writable:510:10)
      at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)
      at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)
      at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139) {
    errno: -32,
    code: 'EPIPE',
    syscall: 'write'
  },
  level: 'error',
  message: 'uncaughtException: write EPIPE\n' +
    'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  stack: 'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  exception: true,
  date: 'Tue Nov 25 2025 19:01:15 GMT+0700 (Indochina Time)',
  process: {
    pid: 62916,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 90947584,
      heapTotal: 56803328,
      heapUsed: 27539168,
      external: 2238348,
      arrayBuffers: 18173
    }
  },
  os: {
    loadavg: [ 4.4462890625, 4.95458984375, 6.7255859375 ],
    uptime: 706731
  },
  trace: [
    {
      column: 15,
      file: 'node:internal/stream_base_commons',
      function: 'afterWriteDispatched',
      line: 161,
      method: null,
      native: false
    },
    {
      column: 3,
      file: 'node:internal/stream_base_commons',
      function: 'writeGeneric',
      line: 152,
      method: null,
      native: false
    },
    {
      column: 11,
      file: 'node:net',
      function: 'Socket._writeGeneric',
      line: 958,
      method: '_writeGeneric',
      native: false
    },
    {
      column: 8,
      file: 'node:net',
      function: 'Socket._write',
      line: 970,
      method: '_write',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/streams/writable',
      function: 'writeOrBuffer',
      line: 572,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: '_write',
      line: 501,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: 'Writable.write',
      line: 510,
      method: 'write',
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js',
      function: 'Console.log',
      line: 87,
      method: 'log',
      native: false
    },
    {
      column: 17,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js',
      function: 'Console._write',
      line: 103,
      method: '_write',
      native: false
    },
    {
      column: 139,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js',
      function: 'doWrite',
      line: 390,
      method: null,
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:01:15'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/routes/user.js:132
        }]ttributes: ['id', 'name'],
          ^^^^^^^^^
  
  SyntaxError: Unexpected identifier 'ttributes'
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: "uncaughtException: Unexpected identifier 'ttributes'\n" +
    '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:132\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:132\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 19:12:41 GMT+0700 (Indochina Time)',
  process: {
    pid: 71624,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86212608,
      heapTotal: 55279616,
      heapUsed: 23648024,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: { loadavg: [ 6.4580078125, 5.896484375, 6.1953125 ], uptime: 707417 },
  trace: [
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 20,
      file: '/Users/alex/Desktop/ctf-platform/backend/app.js',
      function: null,
      line: 16,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:12:41'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/routes/user.js:132
        }]ttributes: ['id', 'name'],
          ^^^^^^^^^
  
  SyntaxError: Unexpected identifier 'ttributes'
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: "uncaughtException: Unexpected identifier 'ttributes'\n" +
    '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:132\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:132\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 19:18:38 GMT+0700 (Indochina Time)',
  process: {
    pid: 74549,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86884352,
      heapTotal: 55803904,
      heapUsed: 23576768,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 7.77685546875, 5.72314453125, 5.82568359375 ],
    uptime: 707774
  },
  trace: [
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 20,
      file: '/Users/alex/Desktop/ctf-platform/backend/app.js',
      function: null,
      line: 16,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:18:38'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/routes/user.js:133
        }]ttributes: ['id', 'name'],
          ^^^^^^^^^
  
  SyntaxError: Unexpected identifier 'ttributes'
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: "uncaughtException: Unexpected identifier 'ttributes'\n" +
    '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 19:18:56 GMT+0700 (Indochina Time)',
  process: {
    pid: 74695,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86179840,
      heapTotal: 55541760,
      heapUsed: 23679800,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 8.79443359375, 6.0947265625, 5.95654296875 ],
    uptime: 707792
  },
  trace: [
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 20,
      file: '/Users/alex/Desktop/ctf-platform/backend/app.js',
      function: null,
      line: 16,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:18:56'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/routes/user.js:133
        }]ttributes: ['id', 'name'],
          ^^^^^^^^^
  
  SyntaxError: Unexpected identifier 'ttributes'
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: "uncaughtException: Unexpected identifier 'ttributes'\n" +
    '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 19:19:07 GMT+0700 (Indochina Time)',
  process: {
    pid: 74804,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86736896,
      heapTotal: 56066048,
      heapUsed: 23730288,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 11.50634765625, 6.765625, 6.19580078125 ],
    uptime: 707803
  },
  trace: [
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 20,
      file: '/Users/alex/Desktop/ctf-platform/backend/app.js',
      function: null,
      line: 16,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:19:07'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/routes/user.js:133
        }]ttributes: ['id', 'name'],
          ^^^^^^^^^
  
  SyntaxError: Unexpected identifier 'ttributes'
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: "uncaughtException: Unexpected identifier 'ttributes'\n" +
    '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 19:19:10 GMT+0700 (Indochina Time)',
  process: {
    pid: 74833,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 88555520,
      heapTotal: 56066048,
      heapUsed: 23541616,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 11.50634765625, 6.765625, 6.19580078125 ],
    uptime: 707806
  },
  trace: [
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 20,
      file: '/Users/alex/Desktop/ctf-platform/backend/app.js',
      function: null,
      line: 16,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:19:10'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/routes/user.js:133
        }]ttributes: ['id', 'name'],
          ^^^^^^^^^
  
  SyntaxError: Unexpected identifier 'ttributes'
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: "uncaughtException: Unexpected identifier 'ttributes'\n" +
    '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 19:19:21 GMT+0700 (Indochina Time)',
  process: {
    pid: 74924,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 88440832,
      heapTotal: 55541760,
      heapUsed: 23664824,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 12.29052734375, 7.1689453125, 6.34912109375 ],
    uptime: 707817
  },
  trace: [
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 20,
      file: '/Users/alex/Desktop/ctf-platform/backend/app.js',
      function: null,
      line: 16,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:19:21'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/routes/user.js:133
        }]ttributes: ['id', 'name'],
          ^^^^^^^^^
  
  SyntaxError: Unexpected identifier 'ttributes'
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: "uncaughtException: Unexpected identifier 'ttributes'\n" +
    '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 19:19:36 GMT+0700 (Indochina Time)',
  process: {
    pid: 75327,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86540288,
      heapTotal: 55541760,
      heapUsed: 23712808,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 18.40380859375, 8.68408203125, 6.8984375 ],
    uptime: 707832
  },
  trace: [
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 20,
      file: '/Users/alex/Desktop/ctf-platform/backend/app.js',
      function: null,
      line: 16,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:19:36'
}
{
  error: /Users/alex/Desktop/ctf-platform/backend/routes/user.js:133
        }]ttributes: ['id', 'name'],
          ^^^^^^^^^
  
  SyntaxError: Unexpected identifier 'ttributes'
      at wrapSafe (node:internal/modules/cjs/loader:1472:18)
      at Module._compile (node:internal/modules/cjs/loader:1501:20)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)
      at Module.load (node:internal/modules/cjs/loader:1275:32)
      at Module._load (node:internal/modules/cjs/loader:1096:12)
      at Module.require (node:internal/modules/cjs/loader:1298:19)
      at require (node:internal/modules/helpers:182:18)
      at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)
      at Module._compile (node:internal/modules/cjs/loader:1529:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1613:10),
  level: 'error',
  message: "uncaughtException: Unexpected identifier 'ttributes'\n" +
    '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  stack: '/Users/alex/Desktop/ctf-platform/backend/routes/user.js:133\n' +
    "      }]ttributes: ['id', 'name'],\n" +
    '        ^^^^^^^^^\n' +
    '\n' +
    "SyntaxError: Unexpected identifier 'ttributes'\n" +
    '    at wrapSafe (node:internal/modules/cjs/loader:1472:18)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1501:20)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)\n' +
    '    at Module.load (node:internal/modules/cjs/loader:1275:32)\n' +
    '    at Module._load (node:internal/modules/cjs/loader:1096:12)\n' +
    '    at Module.require (node:internal/modules/cjs/loader:1298:19)\n' +
    '    at require (node:internal/modules/helpers:182:18)\n' +
    '    at Object.<anonymous> (/Users/alex/Desktop/ctf-platform/backend/app.js:16:20)\n' +
    '    at Module._compile (node:internal/modules/cjs/loader:1529:14)\n' +
    '    at Module._extensions..js (node:internal/modules/cjs/loader:1613:10)',
  exception: true,
  date: 'Tue Nov 25 2025 19:19:59 GMT+0700 (Indochina Time)',
  process: {
    pid: 75932,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 86392832,
      heapTotal: 55541760,
      heapUsed: 23726704,
      external: 2206637,
      arrayBuffers: 17055
    }
  },
  os: {
    loadavg: [ 16.80810546875, 8.95947265625, 7.03857421875 ],
    uptime: 707855
  },
  trace: [
    {
      column: 18,
      file: 'node:internal/modules/cjs/loader',
      function: 'wrapSafe',
      line: 1472,
      method: null,
      native: false
    },
    {
      column: 20,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1501,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    },
    {
      column: 32,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.load',
      line: 1275,
      method: 'load',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._load',
      line: 1096,
      method: '_load',
      native: false
    },
    {
      column: 19,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module.require',
      line: 1298,
      method: 'require',
      native: false
    },
    {
      column: 18,
      file: 'node:internal/modules/helpers',
      function: 'require',
      line: 182,
      method: null,
      native: false
    },
    {
      column: 20,
      file: '/Users/alex/Desktop/ctf-platform/backend/app.js',
      function: null,
      line: 16,
      method: null,
      native: false
    },
    {
      column: 14,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._compile',
      line: 1529,
      method: '_compile',
      native: false
    },
    {
      column: 10,
      file: 'node:internal/modules/cjs/loader',
      function: 'Module._extensions..js',
      line: 1613,
      method: '.js',
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:19:59'
}
{
  error: Error: write EPIPE
      at afterWriteDispatched (node:internal/stream_base_commons:161:15)
      at writeGeneric (node:internal/stream_base_commons:152:3)
      at Socket._writeGeneric (node:net:958:11)
      at Socket._write (node:net:970:8)
      at writeOrBuffer (node:internal/streams/writable:572:12)
      at _write (node:internal/streams/writable:501:10)
      at Writable.write (node:internal/streams/writable:510:10)
      at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)
      at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)
      at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139) {
    errno: -32,
    code: 'EPIPE',
    syscall: 'write'
  },
  level: 'error',
  message: 'uncaughtException: write EPIPE\n' +
    'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  stack: 'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  exception: true,
  date: 'Tue Nov 25 2025 19:21:09 GMT+0700 (Indochina Time)',
  process: {
    pid: 78239,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 88784896,
      heapTotal: 56279040,
      heapUsed: 27657664,
      external: 2238348,
      arrayBuffers: 18173
    }
  },
  os: {
    loadavg: [ 8.88525390625, 8.2607421875, 6.92822265625 ],
    uptime: 707925
  },
  trace: [
    {
      column: 15,
      file: 'node:internal/stream_base_commons',
      function: 'afterWriteDispatched',
      line: 161,
      method: null,
      native: false
    },
    {
      column: 3,
      file: 'node:internal/stream_base_commons',
      function: 'writeGeneric',
      line: 152,
      method: null,
      native: false
    },
    {
      column: 11,
      file: 'node:net',
      function: 'Socket._writeGeneric',
      line: 958,
      method: '_writeGeneric',
      native: false
    },
    {
      column: 8,
      file: 'node:net',
      function: 'Socket._write',
      line: 970,
      method: '_write',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/streams/writable',
      function: 'writeOrBuffer',
      line: 572,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: '_write',
      line: 501,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: 'Writable.write',
      line: 510,
      method: 'write',
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js',
      function: 'Console.log',
      line: 87,
      method: 'log',
      native: false
    },
    {
      column: 17,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js',
      function: 'Console._write',
      line: 103,
      method: '_write',
      native: false
    },
    {
      column: 139,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js',
      function: 'doWrite',
      line: 390,
      method: null,
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:21:09'
}
{
  error: Error: write EPIPE
      at afterWriteDispatched (node:internal/stream_base_commons:161:15)
      at writeGeneric (node:internal/stream_base_commons:152:3)
      at Socket._writeGeneric (node:net:958:11)
      at Socket._write (node:net:970:8)
      at writeOrBuffer (node:internal/streams/writable:572:12)
      at _write (node:internal/streams/writable:501:10)
      at Writable.write (node:internal/streams/writable:510:10)
      at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)
      at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)
      at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139) {
    errno: -32,
    code: 'EPIPE',
    syscall: 'write'
  },
  level: 'error',
  message: 'uncaughtException: write EPIPE\n' +
    'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  stack: 'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  exception: true,
  date: 'Tue Nov 25 2025 19:30:23 GMT+0700 (Indochina Time)',
  process: {
    pid: 90526,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 89391104,
      heapTotal: 56541184,
      heapUsed: 27553336,
      external: 2238348,
      arrayBuffers: 18173
    }
  },
  os: {
    loadavg: [ 4.68505859375, 5.9326171875, 6.251953125 ],
    uptime: 708479
  },
  trace: [
    {
      column: 15,
      file: 'node:internal/stream_base_commons',
      function: 'afterWriteDispatched',
      line: 161,
      method: null,
      native: false
    },
    {
      column: 3,
      file: 'node:internal/stream_base_commons',
      function: 'writeGeneric',
      line: 152,
      method: null,
      native: false
    },
    {
      column: 11,
      file: 'node:net',
      function: 'Socket._writeGeneric',
      line: 958,
      method: '_writeGeneric',
      native: false
    },
    {
      column: 8,
      file: 'node:net',
      function: 'Socket._write',
      line: 970,
      method: '_write',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/streams/writable',
      function: 'writeOrBuffer',
      line: 572,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: '_write',
      line: 501,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: 'Writable.write',
      line: 510,
      method: 'write',
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js',
      function: 'Console.log',
      line: 87,
      method: 'log',
      native: false
    },
    {
      column: 17,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js',
      function: 'Console._write',
      line: 103,
      method: '_write',
      native: false
    },
    {
      column: 139,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js',
      function: 'doWrite',
      line: 390,
      method: null,
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:30:23'
}
{
  error: Error: write EPIPE
      at afterWriteDispatched (node:internal/stream_base_commons:161:15)
      at writeGeneric (node:internal/stream_base_commons:152:3)
      at Socket._writeGeneric (node:net:958:11)
      at Socket._write (node:net:970:8)
      at writeOrBuffer (node:internal/streams/writable:572:12)
      at _write (node:internal/streams/writable:501:10)
      at Writable.write (node:internal/streams/writable:510:10)
      at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)
      at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)
      at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139) {
    errno: -32,
    code: 'EPIPE',
    syscall: 'write'
  },
  level: 'error',
  message: 'uncaughtException: write EPIPE\n' +
    'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  stack: 'Error: write EPIPE\n' +
    '    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n' +
    '    at writeGeneric (node:internal/stream_base_commons:152:3)\n' +
    '    at Socket._writeGeneric (node:net:958:11)\n' +
    '    at Socket._write (node:net:970:8)\n' +
    '    at writeOrBuffer (node:internal/streams/writable:572:12)\n' +
    '    at _write (node:internal/streams/writable:501:10)\n' +
    '    at Writable.write (node:internal/streams/writable:510:10)\n' +
    '    at Console.log (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js:87:23)\n' +
    '    at Console._write (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js:103:17)\n' +
    '    at doWrite (/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js:390:139)',
  exception: true,
  date: 'Tue Nov 25 2025 19:34:32 GMT+0700 (Indochina Time)',
  process: {
    pid: 95018,
    uid: 501,
    gid: 20,
    cwd: '/Users/alex/Desktop/ctf-platform/backend',
    execPath: '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
    version: 'v20.19.4',
    argv: [
      '/Users/alex/.nvm/versions/node/v20.19.4/bin/node',
      '/Users/alex/Desktop/ctf-platform/backend/app.js'
    ],
    memoryUsage: {
      rss: 88981504,
      heapTotal: 56541184,
      heapUsed: 27471384,
      external: 2238348,
      arrayBuffers: 18173
    }
  },
  os: {
    loadavg: [ 8.326171875, 7.794921875, 7.00439453125 ],
    uptime: 708728
  },
  trace: [
    {
      column: 15,
      file: 'node:internal/stream_base_commons',
      function: 'afterWriteDispatched',
      line: 161,
      method: null,
      native: false
    },
    {
      column: 3,
      file: 'node:internal/stream_base_commons',
      function: 'writeGeneric',
      line: 152,
      method: null,
      native: false
    },
    {
      column: 11,
      file: 'node:net',
      function: 'Socket._writeGeneric',
      line: 958,
      method: '_writeGeneric',
      native: false
    },
    {
      column: 8,
      file: 'node:net',
      function: 'Socket._write',
      line: 970,
      method: '_write',
      native: false
    },
    {
      column: 12,
      file: 'node:internal/streams/writable',
      function: 'writeOrBuffer',
      line: 572,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: '_write',
      line: 501,
      method: null,
      native: false
    },
    {
      column: 10,
      file: 'node:internal/streams/writable',
      function: 'Writable.write',
      line: 510,
      method: 'write',
      native: false
    },
    {
      column: 23,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston/lib/winston/transports/console.js',
      function: 'Console.log',
      line: 87,
      method: 'log',
      native: false
    },
    {
      column: 17,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/modern.js',
      function: 'Console._write',
      line: 103,
      method: '_write',
      native: false
    },
    {
      column: 139,
      file: '/Users/alex/Desktop/ctf-platform/backend/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js',
      function: 'doWrite',
      line: 390,
      method: null,
      native: false
    }
  ],
  service: 'ctf-platform',
  timestamp: '2025-11-25 19:34:32'
}
